<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Gator Water Flinger ‚Äî F/J Aim, Space Fling</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üêä</text></svg>">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
      background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 45%, #B6E3EE 100%);
      overflow: hidden;
      color: #1e2a14;
    }

    #app {
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      padding: 18px 18px 22px;
      gap: 14px;
    }

    #hud {
      width: min(980px, 96vw);
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
      user-select: none;
    }

    .pill {
      background: rgba(255,255,255,0.92);
      border: 2px solid rgba(0,0,0,0.15);
      box-shadow: 0 6px 18px rgba(0,0,0,0.12);
      padding: 10px 14px;
      border-radius: 16px;
      font-weight: 700;
      font-size: 16px;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      min-height: 42px;
    }

    .meter {
      width: 160px;
      height: 12px;
      border-radius: 999px;
      background: rgba(0,0,0,0.08);
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.12);
    }
    .meter > div {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #FFD700, #FFB300);
      border-radius: 999px;
      transition: width 120ms linear;
    }

    #stage {
      width: min(980px, 96vw);
      aspect-ratio: 16 / 9;
      background: rgba(255,255,255,0.25);
      border-radius: 22px;
      box-shadow: 0 12px 28px rgba(0,0,0,0.18);
      border: 4px solid rgba(255,255,255,0.55);
      position: relative;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
      background: rgba(0,0,0,0.45);
      color: white;
    }

    #overlay.hidden { display: none; }

    .card {
      width: min(720px, 92%);
      background: rgba(255,255,255,0.96);
      color: #173014;
      border-radius: 22px;
      padding: 22px 22px;
      text-align: center;
      box-shadow: 0 14px 44px rgba(0,0,0,0.25);
      border: 3px solid rgba(0,0,0,0.12);
    }

    .card h1 {
      font-size: 34px;
      margin-bottom: 6px;
      color: #2d5016;
    }
    .card p {
      font-size: 18px;
      line-height: 1.35;
      margin: 10px 0;
      color: #243b1d;
    }

    .big-keys {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 14px 0 10px;
      user-select: none;
    }

    .key {
      background: white;
      border: 2px solid #2c2c2c;
      border-radius: 14px;
      padding: 12px 14px;
      min-width: 130px;
      text-align: center;
      box-shadow: 0 5px 10px rgba(0,0,0,0.18);
      transition: transform 0.08s, background 0.08s, border-color 0.08s, box-shadow 0.08s;
      font-weight: 900;
      color: #172012;
    }
    .key small {
      display: block;
      margin-top: 4px;
      font-weight: 700;
      opacity: 0.75;
      font-size: 12px;
    }
    .key.space { min-width: 280px; }
    .key.aiming {
      background: #FFF4C2;
      border-color: #B08200;
      box-shadow: 0 8px 16px rgba(255, 180, 0, 0.35);
      transform: translateY(-1px);
    }
    .key.pressed {
      background: #C8E6C9;
      transform: translateY(2px) scale(0.98);
      border-color: #66BB6A;
    }

    .btn-row {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 12px;
    }

    button {
      border: none;
      border-radius: 14px;
      padding: 12px 18px;
      font-weight: 900;
      font-size: 18px;
      cursor: pointer;
      background: #4CAF50;
      color: white;
      box-shadow: 0 8px 18px rgba(0,0,0,0.18);
      transition: transform 0.12s, background 0.12s;
      font-family: inherit;
    }
    button:hover { background: #45a049; transform: translateY(-1px); }
    button.secondary { background: #2d5016; }
    button.secondary:hover { background: #244213; }

    #bottom {
      width: min(980px, 96vw);
      display: flex;
      justify-content: center;
    }

    #toast {
      position: absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 14px;
      background: rgba(255,255,255,0.92);
      border: 2px solid rgba(0,0,0,0.15);
      border-radius: 14px;
      box-shadow: 0 10px 22px rgba(0,0,0,0.18);
      font-weight: 800;
      color: #2d5016;
      display: none;
      z-index: 10;
      pointer-events: none;
      user-select: none;
      max-width: 92%;
      text-align: center;
    }
    #toast.show { display: block; }

    .treat-stage {
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 18px;
      margin: 14px 0 8px;
      min-height: 120px;
      user-select: none;
    }
    .treat-stage .gator-eat {
      font-size: 92px;
      transform: scaleX(-1);
      animation: gator-chomp 1.1s ease-in-out infinite;
      filter: saturate(1.02);
    }
    .treat-stage .treat {
      font-size: 62px;
      animation: treat-to-mouth 1.1s ease-in-out infinite;
      transform-origin: center;
    }
    .treat-stage .sparkle {
      font-size: 28px;
      opacity: 0.0;
      animation: sparkle-pop 1.1s ease-in-out infinite;
    }

    @keyframes gator-chomp {
      0%, 55% { transform: scaleX(-1) translateY(0px) scale(1); }
      65% { transform: scaleX(-1) translateY(-2px) scale(1.06) rotate(2deg); }
      78% { transform: scaleX(-1) translateY(1px) scale(0.98) rotate(-3deg); }
      100% { transform: scaleX(-1) translateY(0px) scale(1); }
    }

    @keyframes treat-to-mouth {
      0% { opacity: 0; transform: translateX(140px) translateY(-34px) scale(1); }
      12% { opacity: 1; }
      55% { opacity: 1; transform: translateX(26px) translateY(-10px) scale(1); }
      72% { opacity: 1; transform: translateX(6px) translateY(-2px) scale(0.7); }
      82% { opacity: 0; transform: translateX(0px) translateY(2px) scale(0.15); }
      100% { opacity: 0; transform: translateX(0px) translateY(2px) scale(0.15); }
    }

    @keyframes sparkle-pop {
      0%, 60% { opacity: 0; transform: translateY(0px) scale(0.6); }
      70% { opacity: 0.9; transform: translateY(-10px) scale(1.1); }
      85% { opacity: 0.0; transform: translateY(-16px) scale(1.2); }
      100% { opacity: 0; transform: translateY(-16px) scale(1.2); }
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="hud">
      <div class="pill"><span>üèÅ</span><span id="hud-level">Level: 1 / 12</span></div>
      <div class="pill"><span>üêä</span><span id="hud-mode">Aim: Left</span></div>
      <div class="pill"><span>üéØ</span><span id="hud-score">Score: 0</span></div>
      <div class="pill"><span>‚ö°</span><span id="hud-streak">Streak: 0</span></div>
      <div class="pill"><span>‚ù§Ô∏è</span><span id="hud-lives">Lives: ‚ù§‚ù§‚ù§</span></div>
      <div class="pill">
        <span id="hud-treat-icon">üç¨</span>
        <span id="hud-treat">Treat: 0%</span>
        <span class="meter" aria-label="Treat meter"><div id="treat-bar"></div></span>
      </div>
    </div>

    <div id="stage">
      <div id="toast"></div>
      <canvas id="game" width="1280" height="720"></canvas>
      <div id="overlay">
        <div class="card">
          <h1>üêä Swamp Treat Defense üç¨</h1>
          <p>
            Keep your <b>thumb on Space</b> and your <b>index fingers on F and J</b>.
            Enemies rush in from the sides ‚Äî don‚Äôt look down!
          </p>
          <div class="big-keys" aria-label="Controls">
            <div class="key" id="key-f">F<small>aim left (flies ü™∞)</small></div>
            <div class="key space" id="key-space">SPACE<small>fling water üí¶</small></div>
            <div class="key" id="key-j">J<small>aim right (jaguars üêÜ)</small></div>
          </div>
          <p>
            Beat <b>100 levels</b> across <b>25 treat quests</b>. Fill the meter to earn each treat!
            If enemies reach you, you lose hearts.
          </p>
          <div class="btn-row">
            <button id="start-btn">Start</button>
          </div>
          <p style="font-size: 14px; opacity: 0.8; margin-top: 10px;">
            Tip: Press <b>F</b>/<b>J</b> to aim, <b>Space</b> to fling. Every 4 levels your gator earns a bigger treat!
          </p>
        </div>
      </div>
    </div>

    <div id="bottom">
      <div class="big-keys" style="margin: 0;">
        <div class="key" id="key-f-2">F<small>flies ü™∞</small></div>
        <div class="key space" id="key-space-2">SPACE<small>fling üí¶</small></div>
        <div class="key" id="key-j-2">J<small>jaguars üêÜ</small></div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const overlay = document.getElementById('overlay');
    const toast = document.getElementById('toast');
    const startBtn = document.getElementById('start-btn');

    const hudLevel = document.getElementById('hud-level');
    const hudMode = document.getElementById('hud-mode');
    const hudScore = document.getElementById('hud-score');
    const hudStreak = document.getElementById('hud-streak');
    const hudLives = document.getElementById('hud-lives');
    const hudTreat = document.getElementById('hud-treat');
    const hudTreatIcon = document.getElementById('hud-treat-icon');
    const treatBar = document.getElementById('treat-bar');

    const keyEls = {
      f: [document.getElementById('key-f'), document.getElementById('key-f-2')],
      j: [document.getElementById('key-j'), document.getElementById('key-j-2')],
      space: [document.getElementById('key-space'), document.getElementById('key-space-2')],
    };

    function setKeyClass(which, className, on) {
      const els = keyEls[which] || [];
      for (const el of els) {
        if (!el) continue;
        el.classList.toggle(className, !!on);
      }
    }

    function showToast(message, ms = 900) {
      toast.textContent = message;
      toast.classList.add('show');
      window.clearTimeout(showToast._t);
      showToast._t = window.setTimeout(() => toast.classList.remove('show'), ms);
    }

    const TOTAL_LEVELS = 100;

    // 25 treats, one per 4-level quest - getting bigger and more elaborate
    const TREATS = [
      // Quest 1-5: Simple snacks
      { emoji: 'üç¨', name: 'Candy', size: 1.0 },
      { emoji: 'üç≠', name: 'Lollipop', size: 1.0 },
      { emoji: 'üç™', name: 'Cookie', size: 1.0 },
      { emoji: 'üßÅ', name: 'Cupcake', size: 1.1 },
      { emoji: 'üç©', name: 'Donut', size: 1.1 },
      // Quest 6-10: Sweet treats
      { emoji: 'üç´', name: 'Chocolate', size: 1.15 },
      { emoji: 'üç®', name: 'Ice Cream', size: 1.2 },
      { emoji: 'üç¶', name: 'Soft Serve', size: 1.2 },
      { emoji: 'ü•ß', name: 'Pie', size: 1.25 },
      { emoji: 'üéÇ', name: 'Birthday Cake', size: 1.3 },
      // Quest 11-15: Fancy desserts
      { emoji: 'üç∞', name: 'Shortcake', size: 1.35 },
      { emoji: 'ü•Æ', name: 'Moon Cake', size: 1.4 },
      { emoji: 'üç°', name: 'Dango', size: 1.4 },
      { emoji: 'üçÆ', name: 'Flan', size: 1.45 },
      { emoji: 'üßá', name: 'Waffle Stack', size: 1.5 },
      // Quest 16-20: Premium rewards
      { emoji: 'ü•û', name: 'Pancake Tower', size: 1.55 },
      { emoji: 'üçø', name: 'Mega Popcorn', size: 1.6 },
      { emoji: 'ü•ê', name: 'Golden Croissant', size: 1.65 },
      { emoji: 'üçØ', name: 'Honey Pot', size: 1.7 },
      { emoji: 'üéÅ', name: 'Mystery Box', size: 1.75 },
      // Quest 21-25: Legendary treats
      { emoji: 'üëë', name: 'Royal Crown', size: 1.8 },
      { emoji: 'üíé', name: 'Diamond Treat', size: 1.85 },
      { emoji: 'üåü', name: 'Golden Star', size: 1.9 },
      { emoji: 'üèÜ', name: 'Champion Trophy', size: 1.95 },
      { emoji: 'üéä', name: 'Grand Finale', size: 2.0 },
    ];

    // Generate 100 levels with smooth difficulty curve
    const LEVELS = [];
    const LEVEL_NAMES = [
      'Warm Up', 'Getting Started', 'Easy Does It', 'First Steps',
      'Finding Rhythm', 'Steady Pace', 'Building Speed', 'Quick Fingers',
      'Focus Time', 'Stay Sharp', 'Keep Moving', 'Don\'t Blink',
      'Faster Now', 'Pick It Up', 'Swift Moves', 'Rapid Fire',
      'Challenge Mode', 'Stepping Up', 'Getting Serious', 'No Mercy',
      'Speed Demon', 'Lightning Fast', 'Blazing Trail', 'On Fire',
      'Expert Zone', 'Pro Level', 'Master Class', 'Elite Tier',
      'Legendary', 'Mythic', 'Godlike', 'Impossible',
      'Beyond Limits', 'Transcendent', 'Cosmic', 'Galactic',
      'Universal', 'Infinite', 'Eternal', 'Ultimate',
    ];

    for (let i = 0; i < TOTAL_LEVELS; i++) {
      const progress = i / (TOTAL_LEVELS - 1); // 0 to 1
      const eased = progress * progress * (3 - 2 * progress); // Smooth S-curve
      
      // Difficulty parameters gradually increase
      const minInterval = 1.1 - eased * 0.75;  // 1.1 -> 0.35
      const maxInterval = 1.6 - eased * 0.95;  // 1.6 -> 0.65
      const baseSpeed = 125 + eased * 110;     // 125 -> 235
      const speedRamp = 100 + eased * 280;     // 100 -> 380
      const treatPerHit = 13 - Math.floor(eased * 7); // 13 -> 6
      const treatStreakBonus = 0.5 - eased * 0.32;    // 0.5 -> 0.18

      const nameIndex = Math.min(Math.floor(i / 2.5), LEVEL_NAMES.length - 1);
      const levelInQuest = (i % 4) + 1;
      const questNum = Math.floor(i / 4) + 1;
      
      LEVELS.push({
        name: `${LEVEL_NAMES[nameIndex]} ${levelInQuest}`,
        quest: questNum,
        minInterval: Math.round(minInterval * 100) / 100,
        maxInterval: Math.round(maxInterval * 100) / 100,
        baseSpeed: Math.round(baseSpeed),
        speedRamp: Math.round(speedRamp),
        treatPerHit: treatPerHit,
        treatStreakBonus: Math.round(treatStreakBonus * 100) / 100,
      });
    }

    // Helper to get current treat
    function getCurrentTreat(level) {
      const questIndex = Math.floor((level - 1) / 4);
      return TREATS[Math.min(questIndex, TREATS.length - 1)];
    }

    const state = {
      running: false,
      practice: false,
      aimDir: -1, // -1 left, +1 right
      level: 1,
      score: 0,
      streak: 0,
      lives: 3,
      cake: 0, // 0..100
      elapsed: 0, // total elapsed (for subtle background motion)
      levelElapsed: 0,
      spawnT: 0,
      shotCooldown: 0,
      missedShots: 0,
      win: false,
      lose: false,
      lastHitAt: 0,
      enemiesSpawned: 0,  // enemies spawned this level
      flingsUsed: 0,      // flings used this level
    };

    const enemies = [];
    const shots = [];
    const particles = [];

    function resetGame({ practice = false } = {}) {
      state.practice = practice;
      state.score = 0;
      state.elapsed = 0;
      state.level = 1;
      state.win = false;
      state.lose = false;
      startLevel(1);
    }

    function startLevel(levelNumber) {
      state.level = Math.max(1, Math.min(TOTAL_LEVELS, levelNumber));
      state.running = true;
      state.aimDir = -1;
      state.streak = 0;
      state.lives = 3;
      state.cake = 0;
      state.levelElapsed = 0;
      state.spawnT = 0;
      state.shotCooldown = 0;
      state.missedShots = 0;
      state.lastHitAt = 0;
      state.enemiesSpawned = 0;
      state.flingsUsed = 0;

      enemies.length = 0;
      shots.length = 0;
      particles.length = 0;

      overlay.classList.add('hidden');
      updateHud();

      const cfg = LEVELS[state.level - 1];
      const treat = getCurrentTreat(state.level);
      const questNum = Math.floor((state.level - 1) / 4) + 1;
      showToast(`Level ${state.level} ‚Äî Quest ${questNum}: ${treat.name} ${treat.emoji}`, 1100);
    }

    function updateHud() {
      const treat = getCurrentTreat(state.level);
      const questNum = Math.floor((state.level - 1) / 4) + 1;
      hudLevel.textContent = `Level: ${state.level} / ${TOTAL_LEVELS} (Quest ${questNum}/25)`;
      hudMode.textContent = `Aim: ${state.aimDir < 0 ? 'Left' : 'Right'}`;
      hudScore.textContent = `Score: ${state.score}`;
      hudStreak.textContent = `Streak: ${state.streak}`;
      hudLives.textContent = `Lives: ${'‚ù§'.repeat(Math.max(0, state.lives))}${'‚ô°'.repeat(Math.max(0, 3 - state.lives))}`;
      const treatPct = Math.max(0, Math.min(100, state.cake));
      hudTreatIcon.textContent = treat.emoji;
      hudTreat.textContent = `${treat.name}: ${treatPct.toFixed(0)}%`;
      treatBar.style.width = `${treatPct}%`;

      setKeyClass('f', 'aiming', state.aimDir < 0);
      setKeyClass('j', 'aiming', state.aimDir > 0);
    }

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }
    function rand(a, b) { return a + Math.random() * (b - a); }

    function resizeCanvasToDisplaySize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      const w = Math.round(rect.width * dpr);
      const h = Math.round(rect.height * dpr);
      if (canvas.width !== w || canvas.height !== h) {
        canvas.width = w;
        canvas.height = h;
      }
    }

    function spawnEnemy() {
      const w = canvas.width;
      const h = canvas.height;
      const groundY = h * 0.84;

      const side = Math.random() < 0.5 ? 'left' : 'right';
      const x = side === 'left' ? -40 : (w + 40);
      const y = rand(h * 0.18, groundY - h * 0.18);

      const cfg = LEVELS[state.level - 1];
      const rampSeconds = state.practice ? 26 : 20;
      const difficulty = clamp01(state.levelElapsed / rampSeconds);
      const practiceMult = state.practice ? 0.86 : 1.0;
      const speed = (cfg.baseSpeed + difficulty * cfg.speedRamp + Math.min(160, state.streak * 2.2)) * practiceMult;
      const emoji = side === 'left' ? 'ü™∞' : 'üêÜ';
      const r = side === 'left' ? 18 : 22;

      enemies.push({
        side,
        emoji,
        x,
        y,
        r,
        speed,
        wobble: rand(0, Math.PI * 2),
      });
      state.enemiesSpawned++;
    }

    function getAvailableFlings() {
      // Flings available = enemies spawned - flings used + 4 buffer
      return Math.max(0, state.enemiesSpawned - state.flingsUsed + 4);
    }

    function shoot() {
      if (!state.running || state.win || state.lose) return;
      if (state.shotCooldown > 0) return;
      
      // Check if we have flings available
      if (getAvailableFlings() <= 0) {
        showToast('Out of water! Wait for more enemies...', 600);
        return;
      }

      state.shotCooldown = 0.145; // seconds
      state.flingsUsed++;
      setKeyClass('space', 'pressed', true);
      window.setTimeout(() => setKeyClass('space', 'pressed', false), 90);

      const w = canvas.width;
      const h = canvas.height;
      const gatorX = w * 0.5;
      const gatorY = h * 0.86;

      // Hitscan: find the nearest enemy on the aimed side
      const targetSide = state.aimDir < 0 ? 'left' : 'right';
      let nearestEnemy = null;
      let nearestDist = Infinity;
      let nearestIndex = -1;

      for (let i = 0; i < enemies.length; i++) {
        const e = enemies[i];
        if (e.side !== targetSide) continue;
        if (e.targeted) continue; // Skip enemies already being chased by water

        const dist = Math.hypot(e.x - gatorX, e.y - gatorY);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearestEnemy = e;
          nearestIndex = i;
        }
      }

      if (nearestEnemy) {
        // Mark enemy as targeted so we don't shoot it again (but it keeps moving!)
        nearestEnemy.targeted = true;
        
        // Create a tracking shot that chases the enemy
        const speed = state.practice ? 700 : 800;
        shots.push({
          x: gatorX + state.aimDir * 18,
          y: gatorY - 34,
          vx: 0, // will be calculated each frame to track enemy
          vy: 0,
          speed: speed,
          r: 7,
          life: 3.0, // longer life since it's chasing
          targetEnemy: nearestEnemy,
          hasHit: false,
        });
        // Score is awarded when the shot actually hits, not now
      } else {
        // No enemy on that side - create visual shot that goes off screen
        const dirX = state.aimDir * 1.0;
        const dirY = -0.3;
        const len = Math.hypot(dirX, dirY) || 1;
        const speed = state.practice ? 940 : 1020;
        shots.push({
          x: gatorX + state.aimDir * 18,
          y: gatorY - 34,
          vx: (dirX / len) * speed,
          vy: (dirY / len) * speed,
          r: 7,
          life: 1.5, // long enough to fly off screen
        });

        state.missedShots += 1;
        if (state.missedShots >= 2 && state.streak > 0) {
          state.streak = 0;
          showToast('No enemies on that side ‚Äî check your aim (F/J)!', 720);
        }
      }
    }

    function addSplash(x, y, n = 10) {
      for (let i = 0; i < n; i++) {
        particles.push({
          x, y,
          vx: rand(-220, 220),
          vy: rand(-220, 220),
          r: rand(2, 5),
          a: 1,
          life: rand(0.35, 0.65),
          t: 0,
        });
      }
    }

    function endGame(win) {
      state.running = false;
      state.win = !!win;
      state.lose = !win;

      const treat = getCurrentTreat(state.level);
      const questNum = Math.floor((state.level - 1) / 4) + 1;
      const questStartLevel = (questNum - 1) * 4 + 1;
      
      const title = win ? `${treat.emoji} Treat secured! ${treat.emoji}` : 'Swamp trouble! üí•';
      const msg = win
        ? `Your gator defended the swamp and earned the ${treat.name}!\nFinal score: ${state.score}`
        : `Enemies reached you.\nScore: ${state.score}`;

      overlay.innerHTML = `
        <div class="card">
          <h1>${title}</h1>
          <p style="white-space: pre-line">${msg}</p>
          <div class="btn-row" style="margin-top: 18px;">
            <button id="restart-btn">Retry Quest ${questNum} (Level ${questStartLevel})</button>
          </div>
        </div>
      `;
      overlay.classList.remove('hidden');

      const restart = overlay.querySelector('#restart-btn');
      if (restart) restart.addEventListener('click', () => {
        state.score = 0;
        state.elapsed = 0;
        state.win = false;
        state.lose = false;
        startLevel(questStartLevel);
      });
    }

    function showSetVictory({ treatEmoji, title, message, nextLabel, onNext }) {
      state.running = false;
      overlay.innerHTML = `
        <div class="card">
          <h1>${title}</h1>
          <p style="white-space: pre-line">${message}</p>
          <div class="treat-stage" aria-label="Gator eating treat animation">
            <div class="sparkle">‚ú®</div>
            <div class="gator-eat">üêä</div>
            <div class="treat">${treatEmoji}</div>
            <div class="sparkle">‚ú®</div>
          </div>
          <div class="btn-row" style="margin-top: 18px;">
            <button id="next-btn">${nextLabel}</button>
          </div>
          <p style="margin-top: 12px;"><a href="#" id="restart-link" style="font-size: 13px; color: #666; text-decoration: underline;">or restart from level 1</a></p>
        </div>
      `;
      overlay.classList.remove('hidden');

      const nextBtn = overlay.querySelector('#next-btn');
      const restartLink = overlay.querySelector('#restart-link');
      if (nextBtn) nextBtn.addEventListener('click', onNext);
      if (restartLink) restartLink.addEventListener('click', (e) => { e.preventDefault(); resetGame({ practice: false }); });
    }

    function completeLevel() {
      const levelJustBeat = state.level;
      const isQuestEnd = levelJustBeat % 4 === 0;
      const isFinal = levelJustBeat === TOTAL_LEVELS;
      const questNum = Math.floor((levelJustBeat - 1) / 4) + 1;
      const treat = getCurrentTreat(levelJustBeat);

      // Quick flow for non-quest-end levels: short toast + auto-advance.
      if (!isQuestEnd) {
        state.running = false;
        overlay.classList.add('hidden');
        showToast(`Level ${levelJustBeat} complete! ${treat.emoji}`, 800);
        window.setTimeout(() => startLevel(levelJustBeat + 1), 900);
        return;
      }

      // Quest victory screens every 4 levels
      if (isFinal) {
        showSetVictory({
          treatEmoji: treat.emoji,
          title: `üéä ALL 100 LEVELS COMPLETE! üéä`,
          message: `LEGENDARY! Your gator conquered all 25 treat quests!\nFinal treat: ${treat.name} ${treat.emoji}\nFinal score: ${state.score}`,
          nextLabel: 'Play Again',
          onNext: () => resetGame({ practice: state.practice }),
        });
        return;
      }

      const nextLevel = levelJustBeat + 1;
      const nextTreat = getCurrentTreat(nextLevel);
      showSetVictory({
        treatEmoji: treat.emoji,
        title: `Quest ${questNum}/25 Complete! ${treat.emoji}`,
        message: `Your gator earned the ${treat.name}!\nNext quest: ${nextTreat.name} ${nextTreat.emoji}\nLevel ${nextLevel}/${TOTAL_LEVELS}`,
        nextLabel: `Start Quest ${questNum + 1}`,
        onNext: () => startLevel(nextLevel),
      });
    }

    function tick(dt) {
      resizeCanvasToDisplaySize();
      const w = canvas.width;
      const h = canvas.height;

      state.elapsed += dt;
      state.levelElapsed += dt;
      state.spawnT -= dt;
      state.shotCooldown = Math.max(0, state.shotCooldown - dt);

      // Spawn rate ramps up over time and streak.
      const cfg = LEVELS[state.level - 1];
      const rampSeconds = state.practice ? 26 : 20;
      const difficulty = clamp01(state.levelElapsed / rampSeconds);
      const practiceIntervalMult = state.practice ? 1.18 : 1.0;
      const minInterval = cfg.minInterval * practiceIntervalMult;
      const maxInterval = cfg.maxInterval * practiceIntervalMult;
      const streakBoost = Math.min(0.18, state.streak * 0.004);
      const spawnInterval = (maxInterval - (maxInterval - minInterval) * difficulty) * (1 - streakBoost);

      // Stop spawning once meter is full - just need to clear remaining enemies
      if (state.spawnT <= 0 && state.cake < 100) {
        spawnEnemy();
        state.spawnT = spawnInterval * rand(0.55, 0.95);
      }

      const gatorX = w * 0.5;
      const gatorY = h * 0.86;

      // Update enemies
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.wobble += dt * (e.side === 'left' ? 4.2 : 2.6);
        const wobbleY = Math.sin(e.wobble) * (e.side === 'left' ? 16 : 10);

        const tx = gatorX;
        const ty = gatorY - 10 + wobbleY;
        const dx = tx - e.x;
        const dy = ty - e.y;
        const len = Math.hypot(dx, dy) || 1;
        const nx = dx / len;
        const ny = dy / len;

        // All enemies keep moving (even if targeted by a shot)
        e.x += nx * e.speed * dt;
        e.y += ny * e.speed * dt;

        // Reached gator - enemy hurts you (even if shot was chasing it)
        if (Math.hypot(e.x - gatorX, e.y - gatorY) < (e.r + 26)) {
          enemies.splice(i, 1);
          addSplash(gatorX + rand(-18, 18), gatorY - rand(10, 26), 18);
          state.lives -= 1;
          state.streak = 0;
          state.missedShots = 0;
          state.lastHitAt = performance.now();
          showToast('Ouch! The water didn\'t reach in time!', 850);
          if (state.lives <= 0) {
            updateHud();
            endGame(false);
            return;
          }
        }
      }

      // Update shots - tracking shots chase their target enemy
      for (let i = shots.length - 1; i >= 0; i--) {
        const s = shots[i];
        s.life -= dt;
        
        if (s.targetEnemy && !s.hasHit) {
          const enemyIndex = enemies.indexOf(s.targetEnemy);
          if (enemyIndex >= 0) {
            const e = enemies[enemyIndex];
            // Update velocity to track the moving enemy
            const dx = e.x - s.x;
            const dy = e.y - s.y;
            const dist = Math.hypot(dx, dy) || 1;
            s.vx = (dx / dist) * s.speed;
            s.vy = (dy / dist) * s.speed;
            
            // Check if shot has caught up to enemy
            const hitThreshold = h * 0.035;
            if (dist < hitThreshold) {
              s.hasHit = true;
              addSplash(e.x, e.y, e.side === 'left' ? 10 : 14);
              enemies.splice(enemyIndex, 1);
              // Award score when shot actually hits
              state.missedShots = 0;
              state.streak += 1;
              const streakBonus = Math.min(40, state.streak * 2);
              state.score += 10 + streakBonus;
              const cfg = LEVELS[state.level - 1];
              const treatGain = cfg.treatPerHit + Math.min(10, state.streak) * cfg.treatStreakBonus;
              state.cake = Math.min(100, state.cake + treatGain);
            }
          } else {
            // Enemy already gone (reached gator) - shot missed
            s.hasHit = true;
          }
        }
        
        // Move the shot
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        
        if (s.life <= 0 || s.x < -80 || s.x > w + 80 || s.y < -80 || s.y > h + 80) {
          shots.splice(i, 1);
          continue;
        }
      }

      // Level complete when meter is full AND no enemies remain on screen
      if (state.cake >= 100 && enemies.length === 0 && !state.win && !state.lose) {
        updateHud();
        completeLevel();
        return;
      }

      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.t += dt;
        p.vy += 560 * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        const t = clamp01(p.t / p.life);
        p.a = 1 - t;
        if (p.t >= p.life) particles.splice(i, 1);
      }

      updateHud();
      draw();
    }

    function draw() {
      const w = canvas.width;
      const h = canvas.height;
      const groundY = h * 0.84;

      // Sky
      const sky = ctx.createLinearGradient(0, 0, 0, h);
      sky.addColorStop(0, '#87CEEB');
      sky.addColorStop(0.5, '#98D8E8');
      sky.addColorStop(1, '#BEEBF0');
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, w, h);

      // Subtle clouds
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 7; i++) {
        const x = (i * 0.16 + (state.elapsed * 0.01)) % 1;
        const cx = x * w;
        const cy = h * (0.12 + (i % 3) * 0.06);
        const r = h * (0.06 + (i % 4) * 0.01);
        ctx.beginPath();
        ctx.ellipse(cx, cy, r * 1.2, r * 0.7, 0, 0, Math.PI * 2);
        ctx.ellipse(cx + r * 0.7, cy + r * 0.05, r * 1.0, r * 0.6, 0, 0, Math.PI * 2);
        ctx.ellipse(cx - r * 0.7, cy + r * 0.1, r * 0.9, r * 0.55, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Current treat at top center
      const treat = getCurrentTreat(state.level);
      const treatX = w * 0.5;
      const treatY = h * 0.10;
      const treatSize = Math.round(h * 0.07 * treat.size);
      ctx.font = `${treatSize}px "Apple Color Emoji", "Segoe UI Emoji", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(treat.emoji, treatX, treatY);
      ctx.globalAlpha = 0.85;
      ctx.font = `${Math.round(h * 0.035 * treat.size)}px "Apple Color Emoji", "Segoe UI Emoji", sans-serif`;
      ctx.fillText('‚ú®', treatX - h * 0.06 * treat.size, treatY + h * 0.02);
      ctx.fillText('‚ú®', treatX + h * 0.06 * treat.size, treatY + h * 0.02);
      ctx.globalAlpha = 1;

      // Swamp ground + water
      const mud = ctx.createLinearGradient(0, groundY - h * 0.06, 0, h);
      mud.addColorStop(0, '#7A6A53');
      mud.addColorStop(0.35, '#6B5D4F');
      mud.addColorStop(1, '#4E4338');
      ctx.fillStyle = mud;
      ctx.fillRect(0, groundY - h * 0.06, w, h);

      const waterY = groundY + h * 0.02;
      const water = ctx.createLinearGradient(0, waterY, 0, h);
      water.addColorStop(0, '#4a7c59');
      water.addColorStop(1, '#2d5016');
      ctx.fillStyle = water;
      ctx.fillRect(0, waterY, w, h - waterY);

      // Ripples
      ctx.globalAlpha = 0.12;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = Math.max(1, h * 0.003);
      const rippleOffset = (state.elapsed * 70) % (w * 0.25);
      for (let y = waterY + h * 0.02; y < h; y += h * 0.035) {
        ctx.beginPath();
        for (let x = -w * 0.1; x <= w * 1.1; x += w * 0.08) {
          const yy = y + Math.sin((x + rippleOffset) / (w * 0.09)) * (h * 0.006);
          if (x === -w * 0.1) ctx.moveTo(x, yy);
          else ctx.lineTo(x, yy);
        }
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Zone indicators and aim overlay
      const gatorX = w * 0.5;
      const gatorY = h * 0.86;
      const zoneTop = h * 0.12;
      const zoneBottom = groundY - h * 0.02;
      const zoneHeight = zoneBottom - zoneTop;
      const letterSize = Math.round(h * 0.35);

      // Background letters (always visible, subtle)
      ctx.font = `900 ${letterSize}px system-ui, -apple-system, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Left side - F (subtle background)
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#2d5016';
      ctx.fillText('F', w * 0.25, zoneTop + zoneHeight * 0.5);
      
      // Right side - J (subtle background)
      ctx.fillText('J', w * 0.75, zoneTop + zoneHeight * 0.5);
      ctx.globalAlpha = 1;

      // Active aim overlay - highlights the aimed side
      if (state.aimDir < 0) {
        // Left side active - F
        ctx.fillStyle = 'rgba(255, 200, 50, 0.18)';
        ctx.fillRect(0, zoneTop, w * 0.5, zoneHeight);
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = '#B08200';
        ctx.fillText('F', w * 0.25, zoneTop + zoneHeight * 0.5);
        ctx.globalAlpha = 1;
      } else {
        // Right side active - J
        ctx.fillStyle = 'rgba(255, 200, 50, 0.18)';
        ctx.fillRect(w * 0.5, zoneTop, w * 0.5, zoneHeight);
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = '#B08200';
        ctx.fillText('J', w * 0.75, zoneTop + zoneHeight * 0.5);
        ctx.globalAlpha = 1;
      }

      // Enemies
      for (const e of enemies) {
        const fontSize = e.side === 'left' ? Math.round(h * 0.055) : Math.round(h * 0.06);
        ctx.font = `${fontSize}px "Apple Color Emoji", "Segoe UI Emoji", sans-serif`;
        ctx.fillText(e.emoji, e.x, e.y);
      }

      // Shots - water droplets with high visibility
      for (const s of shots) {
        const shotSize = Math.round(h * 0.045);
        ctx.font = `${shotSize}px "Apple Color Emoji", "Segoe UI Emoji", sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Draw multiple water emojis for visibility
        ctx.fillText('üíß', s.x, s.y);
        ctx.globalAlpha = 0.7;
        ctx.fillText('üí¶', s.x + shotSize * 0.4, s.y - shotSize * 0.3);
        ctx.globalAlpha = 1;
        // Add a bright outline/glow for contrast against blue sky
        ctx.shadowColor = 'rgba(255, 255, 255, 0.9)';
        ctx.shadowBlur = 8;
        ctx.fillText('üíß', s.x, s.y);
        ctx.shadowBlur = 0;
      }

      // Particles
      for (const p of particles) {
        ctx.globalAlpha = p.a;
        ctx.fillStyle = 'rgba(160, 230, 255, 0.95)';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Gator (bottom center) - flips to aim tail toward enemies
      const gatorSize = Math.round(h * 0.09);
      ctx.font = `${gatorSize}px "Apple Color Emoji", "Segoe UI Emoji", sans-serif`;
      ctx.save();
      ctx.translate(gatorX, gatorY);
      // Gator emoji üêä has head on right, tail on left by default
      // Aiming left: tail should point left ‚Üí default orientation (no flip)
      // Aiming right: tail should point right ‚Üí flip horizontally
      if (state.aimDir > 0) {
        ctx.scale(-1, 1); // Flip horizontally when aiming right
      }
      ctx.fillText('üêä', 0, 0);
      ctx.restore();

      // Available flings indicator (water drops under gator)
      const availableFlings = getAvailableFlings();
      const maxDisplayFlings = 12; // Show up to 12 drops
      const displayFlings = Math.min(availableFlings, maxDisplayFlings);
      const dropSize = Math.round(h * 0.028);
      const dropSpacing = dropSize * 1.1;
      const dropsStartX = gatorX - (displayFlings - 1) * dropSpacing * 0.5;
      const dropsY = gatorY + h * 0.055;
      
      ctx.font = `${dropSize}px "Apple Color Emoji", "Segoe UI Emoji", sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      for (let i = 0; i < displayFlings; i++) {
        const dropX = dropsStartX + i * dropSpacing;
        ctx.globalAlpha = 0.9;
        ctx.fillText('üíß', dropX, dropsY);
      }
      // Show +N if more than maxDisplayFlings
      if (availableFlings > maxDisplayFlings) {
        ctx.globalAlpha = 0.8;
        ctx.font = `bold ${Math.round(h * 0.022)}px system-ui, sans-serif`;
        ctx.fillStyle = '#0088cc';
        ctx.fillText(`+${availableFlings - maxDisplayFlings}`, dropsStartX + displayFlings * dropSpacing + dropSize * 0.3, dropsY);
      }
      ctx.globalAlpha = 1;

      // Hurt flash
      const sinceHit = performance.now() - state.lastHitAt;
      if (sinceHit >= 0 && sinceHit < 240) {
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = '#ff1744';
        ctx.fillRect(0, 0, w, h);
        ctx.globalAlpha = 1;
      }
    }

    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.035, (now - last) / 1000);
      last = now;

      if (state.running && !state.win && !state.lose) {
        tick(dt);
      } else {
        // Still render a calm scene behind overlay.
        resizeCanvasToDisplaySize();
        draw();
      }
      requestAnimationFrame(loop);
    }

    function onKeyDown(e) {
      const k = e.key.toLowerCase();
      if (k !== 'f' && k !== 'j' && k !== ' ') {
        if (state.running) {
          state.streak = 0;
          state.missedShots = 0;
          showToast('Only F, J, and Space for this game!', 850);
          updateHud();
        }
        return;
      }

      // Prevent page scrolling on space
      if (k === ' ') e.preventDefault();

      if (k === 'f') {
        state.aimDir = -1;
        setKeyClass('f', 'pressed', true);
        window.setTimeout(() => setKeyClass('f', 'pressed', false), 90);
        updateHud();
        return;
      }
      if (k === 'j') {
        state.aimDir = 1;
        setKeyClass('j', 'pressed', true);
        window.setTimeout(() => setKeyClass('j', 'pressed', false), 90);
        updateHud();
        return;
      }
      if (k === ' ') {
        if (!state.running) return;
        shoot();
        return;
      }
    }

    startBtn.addEventListener('click', () => resetGame({ practice: false }));
    overlay.addEventListener('click', (e) => {
      // Clicking the dark backdrop shouldn't restart by accident.
      if (e.target === overlay) {
        const hasStart = !!overlay.querySelector('#start-btn');
        showToast(hasStart ? 'Click Start to begin.' : 'Use the buttons to continue.', 700);
      }
    });

    window.addEventListener('keydown', onKeyDown, { passive: false });
    window.addEventListener('blur', () => {
      // Gentle stop when tab loses focus
      if (state.running && !state.win && !state.lose) {
        showToast('Back to the game ‚Äî eyes up!', 800);
      }
    });

    updateHud();
    requestAnimationFrame(loop);
  </script>
</body>
</html>

